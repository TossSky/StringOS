.code16
.intel_syntax noprefix
.global _start 
_start:
    # clear
	mov ax, 0x3 				# Функция очистки консоли	
	int 0x10					# Вызов прерывания 0x10 - видео сервис
	
	# print loading
	mov bx, offset loading_str 	# Загрузка в bx строки loading_str
	call puts					# Вызов функции puts (вывод строки, лежащей в bx)
	
	# input symbols
	call input					# Вызов функции input
	# clear
	mov ax, 03					# Функция очистки консоли
	int 0x10					# Вызов прерывания 0x10 - видео сервис
	
	mov dl, 0x01				# Номер диска (носителя)
	mov dh, 0x00				# Номер головки
	mov ch, 0x00				# Номер цилиндра (дорожки)
	mov cl, 0x01				# 2 - номер цил. 6 - номер сектора
	mov al, 0x30 	        	# Количество сектров, взято 48 секторов 
	mov bx, 0x1000				# Адрес буфера, в который считываются данные (со смещением) 0x1000:0x0000
	mov es, bx					# В данном случае адрес со смещением будет равен 0x10000
	xor bx, bx
	mov ah, 0x02				# Функция - считывание заданного количества секторов с диска в память. 
	int 0x13					# Вызов прерывания 0x13 - дисковый ввод/вывод
	
	# Переход в защищённый режим
	cli							# Обязательное отключение прерываний
	lgdt gdt_info      			# Загрузка размера и адреса таблицы дескрипторов 
	in al, 0x92					# Включение адресной линии А20
	or al, 2					#
	out 0x92, al				#
	mov eax, cr0 				# Установка бита PE регистра CR0 - процессор перейдет в защищенный режим
	or al, 1					#
	mov cr0, eax 				#
	jmp 0x8:protected_mode 		# "Дальний" переход для загрузки корректной информации в cs

gdt: 
	# Нулевой дескриптор
	.byte 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	
	
	# Сегмент кода: base=0, size=4Gb, P=1, DPL=0, S=1(user), Type=1(code), Access=00A, G=1, B=32bit
	.byte 0xff, 0xff, 0x00, 0x00, 0x00, 0x9A, 0xCF, 0x00
	
	# Сегмент данных: base=0, size=4Gb, P=1, DPL=0, S=1(user), Type=0(data), Access=0W0, G=1, B=32bit
	.byte 0xff, 0xff, 0x00, 0x00, 0x00, 0x92, 0xCF, 0x00
	
gdt_info:
	.word gdt_info - gdt 		# Размер таблицы (2 байта)
	.word gdt, 0  		 		# 32-битный физический адрес таблицы.

# Функция ввода до 'bm' или 'std' и помещение флага в память (0x9004)
input:
    call shl_					# Битовый сдвиг на 4 бита влево
	mov ah, 0x00				# Функция ожидания нажатия и считывание нажатой клавиши
	int 0x16					# Вызов прерывания 0x16 - работа с клавиатурой
	add buffer[0], al			# В младший байт 4 байтного слова "кладём" введённый символ
	mov ah, 0x0e 				# Функция вывода на текстовый экран символа из al
	int 0x10					# Вызов прерывания 0x10 - видео сервис
	mov al, buffer[0]			# Присваиваем регистру al значение введённого символа
	cmp al, 'm'					# Если в al НЕ символ 'm', то:
	jne std_check				# Переходим в функцию std_check для проверки последнего введённого символа и перед ним
	mov al, buffer[1]			# 
	cmp al, 'b'					# Проверка прошлого введённого символа, равен ли он 'b'
	jne std_check				#
	mov bx, 0x9004				# В регистр bx помещается адрес 0x9004 (выбран произвольно)
	mov cx, 1      				# В регистр cx помещаем значение 1, если была введена 'bm'
	mov [bx], cx				# По адресу 0x9004 помещаем значение cx == 1
	ret							# Возвращаемся из функции
	
# Функция проверки на то, введена ли последовательность 'std'
std_check:
	mov al, buffer[0]			# Присваиваем регистру al значение последнего введённого символа
	cmp al, 'd'					# Если в al НЕ символ 'd', то:
	jne input					# Переходим в функцию input для ввода нового символа
	mov al, buffer[1]			# Присваиваем регистру al значение предпоследнего введённого символа
	cmp al, 't'					# Если в al НЕ символ 't', то:
	jne input					# Переходим в функцию input для ввода нового символа
	mov al, buffer[2]			# Присваиваем регистру al значение предпредпоследнего введённого символа
	cmp al, 's'					# Если в al НЕ символ 's', то:
	jne input					# Переходим в функцию input для ввода нового символа
	mov bx, 0x9004				# В регистр bx помещается адрес 0x9004 (выбран произвольно)
	mov cx, 0					# В регистр cx помещаем значение 0, если была введена 'std'
	mov [bx], cx				# По адресу 0x9004 помещаем значение cx == 0
	ret							# Возвращаемся из функции
	
# Функция битового сдвига на 4 бита влево буфера, где хранится 4 введённых байта
shl_:
	mov al, buffer[2]			
	mov buffer[3], al
	
	mov al, buffer[1]
	mov buffer[2], al
	
	mov al, buffer[0]
	mov buffer[1], al
	
	mov al, 0x00
	mov buffer[0], al
	ret
	
# Функция вывода на экран строки, адрес которой лежит по адресу в bx
puts: 
	mov al, [bx]				# В регистр al помещается символ строки по адресу [bx]
	test al, al					# Проверка - конец ли строки ('\0')
	jz end_puts					# Если да, то выходим из функции
	mov ah, 0x0e 				# Функция вывода на текстовый экран символа из al
	int 0x10					# Вызов прерывания 0x10 - видео сервис
	add bx, 1					# Переход к следующему символу строки по адресу [bx]
	jmp puts					# Возврат к началу функции по циклу
end_puts:
	ret
	
loading_str:
	.asciz "Insert algorithm ('bm' or 'std'): "

# Буфер, в котором находятся 4 последних введённых символа с клавиатуры
buffer:       
	.long 0x00000000
	
# Передача управления от загрузчика ядру
.code32
protected_mode:
	mov ax, 0x10 				# Используется дескриптор с номером 2 в GDT
	mov es, ax
	mov ds, ax
	mov ss, ax
	
	# Передача управления загруженному ядру
	call 0x10000 				# Адрес равен адресу загрузки


inf_loop:
	jmp inf_loop 				# Бесконечный цикл 
.zero (512 - ($ - _start) - 2) 	# Заполнение нулями до границы 512 - 2 текущей точки
.byte 0x55, 0xAA 				#  2 необходимых байта чтобы сектор считался загрузочным
